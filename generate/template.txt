// Package functional implements functional operations for slices of go primitives
package functional

// {{.FunctorName}} implements functional operations for type []{{.Type}}
type {{.FunctorName}} struct {
	slice []{{.Type}}
}

// {{.LiftFuncName}} creates an {{.FunctorName}} from a []{{.Type}}
func {{.LiftFuncName}}(slice []{{.Type}}) {{.FunctorName}} {
	return {{.FunctorName}}{slice: slice}
}

// Collect returns the underlying []{{.Type}}
func (f {{.FunctorName}}) Collect() []{{.Type}} {
	return f.slice
}

// Map returns a new {{.FunctorName}} whose underlying slice is the result of
// applying the input operation to each of its members.
func (f {{.FunctorName}}) Map(op func({{.Type}}) {{.Type}}) {{.FunctorName}} {
	mapped := make([]{{.Type}}, 0, len(f.slice))
	for _, i := range f.slice {
		mapped = append(mapped, op(i))
	}
	return {{.LiftFuncName}}(mapped)
}

// Filter returns a new {{.FunctorName}} whose underlying slice has had members
// exluded that do not satisfy the input filter.
func (f {{.FunctorName}}) Filter(op func({{.Type}}) bool) {{.FunctorName}} {
	var filtered []{{.Type}}
	for _, i := range f.slice {
		if op(i) {
			filtered = append(filtered, i)
		}
	}
	return {{.LiftFuncName}}(filtered)
}

// Exclude returns a new {{.FunctorName}} whose underlying slice has had members
// exluded that satisfy the input filter.
func (f {{.FunctorName}}) Exclude(op func({{.Type}}) bool) {{.FunctorName}} {
	return {{.LiftFuncName}}(f.slice).Filter({{.NegateFuncName}}(op))
}

// Fold applies its input operation to the initial input value and the first
// member of the underlying slice. It successively applies the input operation
// to the result of the previous and the next value in the underlying slice. It
// returns the final value successful operations. If the underlying slice is
// empty then Fold returns the initial input value.
func (f {{.FunctorName}}) Fold(initial {{.Type}}, op func({{.Type}}, {{.Type}}) {{.Type}}) {{.Type}} {
	for _, i := range f.slice {
		initial = op(initial, i)
	}
	return initial
}

// Take returns a new {{.FunctorName}} whose underlying slice has had all
// members after the nth dropped. If n is larger than the length of the
// underlying slice, Take is a no-op.
func (f {{.FunctorName}}) Take(n int) {{.FunctorName}} {
	if n > len(f.slice) {
		return f
	}
	return {{.LiftFuncName}}(f.slice[0:n])
}

// Drop returns a new {{.FunctorName}} whose underlying slice has had the first
// n members dropped. If n is larger than the length of the underlying slice,
// Drop returns an empty StringSliceFunctor.
func (f {{.FunctorName}}) Drop(n int) {{.FunctorName}} {
	if n > len(f.slice) {
		return {{.LiftFuncName}}([]{{.Type}}{})
	}
	return {{.LiftFuncName}}(f.slice[n:len(f.slice)])
}

// WithErrs creates an {{.FunctorErrName}} from a {{.FunctorName}}.
func (f {{.FunctorName}}) WithErrs() {{.FunctorErrName}} {
	return {{.FunctorErrName}}{slice: f.slice}
}

// {{.FunctorErrName}} behaves like {{.FunctorName}} except that operations
// performed over the underlying slice are allowed to return errors. Should
// an error occur then the {{.FunctorErrName}}'s future operations do nothing
// except that Collect will return the error that occurred.
type {{.FunctorErrName}} struct {
	slice []{{.Type}}
	err   error
}

// Collect returns the underlying []{{.Type}} or an error if one has occurred.
func (f {{.FunctorErrName}}) Collect() ([]{{.Type}}, error) {
	if f.err != nil {
		return nil, f.err
	}
	return f.slice, nil
}

// Map returns a new {{.FunctorErrName}} whose underlying slice is the result of
// applying the input operation to each of its members. Should an error occur,
// the underlying slice is lost and subsequent Collect calls will always return
// the error.
func (f {{.FunctorErrName}}) Map(op func({{.Type}}) ({{.Type}}, error)) {{.FunctorErrName}} {
	if f.err != nil {
		return f
	}

	mapped := make([]{{.Type}}, len(f.slice))
	for i := range f.slice {
		new, err := op(f.slice[i])
		if err != nil {
			return {{.FunctorErrName}}{err: err}
		}
		mapped[i] = new
	}
	return {{.LiftFuncName}}(mapped).WithErrs()
}

// Filter returns a new {{.FunctorErrName}} whose underlying slice has had
// members exluded that do not satisfy the input filter. Should an error occur,
// the underlying slice is lost and subsequent Collect calls will always return
// the error.
func (f {{.FunctorErrName}}) Filter(op func({{.Type}}) (bool, error)) {{.FunctorErrName}} {
	if f.err != nil {
		return f
	}

	var filtered []{{.Type}}
	for i := range f.slice {
		include, err := op(f.slice[i])
		if err != nil {
			return {{.FunctorErrName}}{err: err}
		}
		if include {
			filtered = append(filtered, f.slice[i])
		}
	}
	return {{.LiftFuncName}}(filtered).WithErrs()
}

// Exclude returns a new {{.FunctorErrName}} whose underlying slice has had
// members exluded that satisfy the input filter. Should an error occur, the
// underlying slice is lost and subsequent Collect calls will always return the
// error.
func (f {{.FunctorErrName}}) Exclude(op func({{.Type}}) (bool, error)) {{.FunctorErrName}} {
	return {{.LiftFuncName}}(f.slice).WithErrs().Filter({{.NegateWithErrFuncName}}(op))
}

// Fold applies its input operation to the initial input value and the first
// member of the underlying slice. It successively applies the input operation
// to the result of the previous and the next value in the underlying slice. It
// returns the final value successful operations. If the underlying slice is
// empty then Fold returns the initial input value. Should an error have
// previously occurred, that error is immediately returned.
func (f {{.FunctorErrName}}) Fold(initial {{.Type}}, op func({{.Type}}, {{.Type}}) {{.Type}}) ({{.Type}}, error) {
	if f.err != nil {
		return initial, f.err
	}

	return {{.LiftFuncName}}(f.slice).Fold(initial, op), nil
}

// Take returns a new {{.FunctorErrName}} whose underlying slice has had all
// members after the nth dropped. If n is larger than the length of the
// underlying slice, Take is a no-op.
func (f {{.FunctorErrName}}) Take(n int) {{.FunctorErrName}} {
	if f.err != nil {
		return f
	}

	return {{.LiftFuncName}}(f.slice).Take(n).WithErrs()
}

// Drop returns a new {{.FunctorErrName}} whose underlying slice has had the
// first n members dropped. If n is larger than the length of the underlying
// slice, Drop returns an empty {{.FunctorErrName}}.
func (f {{.FunctorErrName}}) Drop(n int) {{.FunctorErrName}} {
	if f.err != nil {
		return f
	}

	return {{.LiftFuncName}}(f.slice).Drop(n).WithErrs()
}

func {{.NegateFuncName}}(op func({{.Type}}) bool) func({{.Type}}) bool {
	return func({{.TypeVar}} {{.Type}}) bool {
		return !op({{.TypeVar}})
	}
}

func {{.NegateWithErrFuncName}}(op func({{.Type}}) (bool, error)) func({{.Type}}) (bool, error) {
	return func({{.TypeVar}} {{.Type}}) (bool, error) {
		result, err := op({{.TypeVar}})
		return !result, err
	}
}
